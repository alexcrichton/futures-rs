use core::ptr;
use core::mem::{forget, size_of};
use core::marker::PhantomData;
use core::cell::Cell;
use super::Unpark;

/// Maximum size of `T` in `UnparkHandle<T>`, in bytes.
/// Configurable by the FUTURES_MAX_UNPARK_BYTES env var at compile-time.
pub const MAX_UNPARK_BYTES: usize = include!(concat!(env!("OUT_DIR"), "/max_unpark_bytes.txt"));

/// A VTable that knows how to clone because the data has a maximum size.
#[derive(Copy)]
struct UnparkVtable {
    unpark: fn(*const ()),
    clone_to_byte_buffer: fn(*const ()) -> [u8; MAX_UNPARK_BYTES],
    drop_in_place: unsafe fn(*mut ()),
}

impl Clone for UnparkVtable {
    fn clone(&self) -> Self {
        UnparkVtable { ..*self }
    }
}

impl UnparkVtable {
    fn new<T: Unpark + Clone>() -> UnparkVtable {
        assert!(size_of::<T>() <= MAX_UNPARK_BYTES);
        UnparkVtable {
            unpark: Self::call_unpark::<T>,
            clone_to_byte_buffer: Self::clone_to_byte_buffer::<T>,
            drop_in_place: Self::drop_in_place::<T>,
        }
    }

    fn call_unpark<T: Unpark>(data: *const ()) {
        let downcasted = unsafe { &*(data as *const _ as *const T) };
        downcasted.unpark()
    }

    /// Returns array with bytes of the cloned data. Safe if data is shorter than MAX_UNPARK_BYTES.
    /// The caller owns the new data and is responsible for dropping it with `drop_in_place<T>`.
    fn clone_to_byte_buffer<T: Clone>(data: *const ()) -> [u8; MAX_UNPARK_BYTES] {
        let downcasted = unsafe { &*(data as *const _ as *const T) };
        obliviate(downcasted.clone())
    }

    /// Make sure the original value is forgotten to avoid double free.
    unsafe fn drop_in_place<T>(data: *mut ()) {
        ptr::drop_in_place(&mut *(data as *mut _ as *mut T));
    }
}

/// `UnparkHandle` is used as an argument to methods like `poll_future`.
///  Each `Task` handle generated by `task::park` will contain a fresh clone
///  of the `unpark` argument provided to `UnparkHandle::new`.
///  Depending on your use case, you may want to wrap your `unpark` value in
///  an `Arc` before passing it to the `UnparkHandle`.
///
/// # Deciding whether to use an `Arc`
/// If you use inner mutability in your `unpark`, then you should carefully
/// consider what happens when it is cloned and what is the behaviour you want.
/// Inner mutability aside, the only difference between using or not an `Arc` should be performance.
/// An `Arc` will cost an allocation upfront and updates an atomic ref count on park,
/// while no `Arc` has no upfront cost but will cost a clone on park.
/// The best strategy depends on how often your futures park and how costly it is to clone `unpark`.
#[allow(missing_debug_implementations)]
pub struct UnparkHandle {
    // A custom trait object that takes ownership of the data as a slice of bytes.
    // Can clone it's `data`, goes inside a `Task`.
    data: [u8; MAX_UNPARK_BYTES],
    vtable: UnparkVtable,
    not_sync : PhantomData<Cell<()>> // Cell is Send but not Sync, convenient.
}

impl UnparkHandle {
    /// Constructs a `UnparkHandle`.
    /// A `Task` handle returned by `park` will contain a clone of the `unpark`
    /// argument provided here. You may want to wrap `unpark` in an `Arc`.
    ///
    /// # Panic
    /// Panics if the size of 'T' is too large. If you get a panic try wrapping the argument
    /// in an `Arc` or setting the FUTURES_MAX_UNPARK_BYTES env var to the size of `T`.
    /// After changing FUTURES_MAX_UNPARK_BYTES you need to recompile `futures`.
    pub fn new<T: Unpark + Clone + 'static>(unpark: T) -> UnparkHandle {
        if size_of::<T>() > MAX_UNPARK_BYTES {
            // Panicking is reasonable since it's easy to catch and fix when testing.
            // Could be a compile time error when we get a const system in Rust.
            // Libraries that pass a user supplied T should do this check themselves if they want to avoid the panic.
            panic!("The size of T is {} bytes which is too large. Try wrapping the unpark argument in an Arc or setting the FUTURES_MAX_UNPARK_BYTES env var.");
        }

        UnparkHandle {
            data: obliviate(unpark),
            vtable: UnparkVtable::new::<T>(),
            not_sync: PhantomData
        }
    }
}

impl Drop for UnparkHandle {
    fn drop(&mut self) {
        unsafe {
            (self.vtable.drop_in_place)(&mut self.data as *mut _ as *mut ());
        }
    }
}

impl Clone for UnparkHandle {
    fn clone(&self) -> Self {
        UnparkHandle {
            data: (self.vtable.clone_to_byte_buffer)(&self.data as *const _ as *const ()),
            ..*self
        }
    }
}

impl Unpark for UnparkHandle {
    fn unpark(&self) {
        (self.vtable.unpark)(&self.data as *const _ as *const ())
    }
}

/// Turns the victim into raw bytes and forgets it.
/// The caller now owns the value and is responsible for dropping it with 'drop_in_place<T>'.
fn obliviate<T>(victim : T) -> [u8; MAX_UNPARK_BYTES] {
    let size = size_of::<T>();
    assert!(size < MAX_UNPARK_BYTES);
    let mut buffer = [0; MAX_UNPARK_BYTES];
    // View victim and buffer as raw bytes.
    let victim_ptr = &victim as *const _ as *const u8;
    let buffer_ptr = &mut buffer as *mut _ as *mut u8;
    // Copy from 'victim' to 'buffer' and forget 'victim'.
    // Semantically, 'buffer' now owns 'victim'.
    unsafe { ptr::copy_nonoverlapping(victim_ptr, buffer_ptr, size); }
    forget(victim);
    buffer
}
