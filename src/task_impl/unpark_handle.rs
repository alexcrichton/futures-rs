use core::ptr;
use core::mem::{forget, size_of};
use super::Unpark;

/// Maximum size in bytes that will fit in a `UnparkObject`.
/// TODO: What should this value be?
/// Should we expose this?
/// We probably want to say that this value may increase but never decrease in a 1.x release.
const MAX_OBJ_BYTES: usize = 64;

/// A VTable that knows how to clone because the data has a maximum size.
#[derive(Copy)]
struct UnparkVtable {
    unpark: fn(*const ()),
    clone_to_byte_buffer: fn(*const ()) -> [u8; MAX_OBJ_BYTES],
    drop_in_place: unsafe fn(*mut ()),
}

impl Clone for UnparkVtable {
    fn clone(&self) -> Self {
        UnparkVtable { ..*self }
    }
}

impl UnparkVtable {
    fn new<T: Unpark + Clone>() -> UnparkVtable {
        assert!(size_of::<T>() <= MAX_OBJ_BYTES);
        UnparkVtable {
            unpark: Self::call_unpark::<T>,
            clone_to_byte_buffer: Self::clone_to_byte_buffer::<T>,
            drop_in_place: Self::drop_in_place::<T>,
        }
    }

    fn call_unpark<T: Unpark>(data: *const ()) {
        let downcasted = unsafe { &*(data as *const _ as *const T) };
        downcasted.unpark()
    }

    /// Returns array with bytes of the cloned data. Make sure data is shorter than MAX_OBJ_BYTES.
    /// The caller owns the new data and is responsible for dropping it with `drop_in_place<T>`.
    fn clone_to_byte_buffer<T: Clone>(data: *const ()) -> [u8; MAX_OBJ_BYTES] {
        let downcasted = unsafe { &*(data as *const _ as *const T) };
        obliviate(downcasted.clone())
    }

    /// Make sure the original value is forgotten to avoid double free.
    unsafe fn drop_in_place<T>(data: *mut ()) {
        ptr::drop_in_place(&mut *(data as *mut _ as *mut T));
    }
}

/// `UnparkHandle` is used as an argument to methods like `poll_future`.
///  Each `Task` handle generated by `task::park` will contain a fresh clone
///  of the `unpark` argument provided to `UnparkHandle::new`.
///  Depending on your use case, you may want to wrap your `unpark` value in
///  an `Arc` before passing it to the `UnparkHandle`.
///
/// # Deciding whether to use an `Arc`
/// If your `unpark` is not `Clone` or has lifetime parameters then you must use an `Arc`.
/// If you use inner mutability in your `unpark`, then you should carefully
/// consider what happens when it is cloned and what is the behaviour you want.
/// Inner mutability aside, the only difference between using or not an `Arc` should be performance.
/// An `Arc` will cost an allocation upfront and updates an atomic ref count on park,
/// while no `Arc` has no upfront cost but will cost a clone on park.
/// The best strategy depends on how often your futures park and how costly it is to clone `unpark`.
#[allow(missing_debug_implementations)]
pub struct UnparkHandle {
    // A custom trait object that takes ownership of the data as a slice of bytes.
    // Can clone it's `data`, goes inside a `Task`.
    data: [u8; MAX_OBJ_BYTES],
    vtable: UnparkVtable,
}

// Means `Task` is not `Sync`.
//impl !Sync for UnparkHandle {}

impl UnparkHandle {
    /// Constructs a `UnparkHandle`.
    /// A `Task` handle returned by `park` will contain a clone of the `unpark`
    /// argument provided here. You may want to wrap `unpark` in an `Arc`.
    ///
    /// # Panic
    /// Panics if the size of 'T' is too large. If you get a panic try wrapping the argument
    /// in an `Arc`.
    pub fn new<T: Unpark + Clone + 'static>(unpark: T) -> UnparkHandle {
        if size_of::<T>() > MAX_OBJ_BYTES {
            // TODO: Panicking here seems reasonable and could be a compile time error when we
            // get a const sytem in Rust. But what about libraries that pass a user supplied type as T?
            // Should we expose MAX_OBJ_BYTES? Offer a version that return an error?
            // We could auto-fallback to Arc, with the downside that we need two UnparkHandle constructors,
            // one with fallback where the user doesn't care because Arc doesn't change his semantics,
            // one without fallback where he cares and wants to decide for himself between Arc or no Arc.
            panic!("The size of T is {} bytes which is too large. Try wrapping the unpark argument in an Arc.");
        }

        UnparkHandle {
            data: obliviate(unpark),
            vtable: UnparkVtable::new::<T>(),
        }
    }
}

impl Drop for UnparkHandle {
    fn drop(&mut self) {
        unsafe {
            (self.vtable.drop_in_place)(&mut self.data as *mut _ as *mut ());
        }
    }
}

impl Clone for UnparkHandle {
    fn clone(&self) -> Self {
        UnparkHandle {
            data: (self.vtable.clone_to_byte_buffer)(&self.data as *const _ as *const ()),
            vtable: self.vtable,
        }
    }
}

impl Unpark for UnparkHandle {
    fn unpark(&self) {
        (self.vtable.unpark)(&self.data as *const _ as *const ())
    }
}

/// Turns the victim into raw bytes and forgets it.
/// The caller now owns the value and is responsible for dropping it with 'drop_in_place<T>'.
fn obliviate<T>(victim : T) -> [u8; MAX_OBJ_BYTES] {
    let size = size_of::<T>();
    assert!(size < MAX_OBJ_BYTES);
    let mut buffer = [0; MAX_OBJ_BYTES];
    // View victim and buffer as raw bytes.
    let victim_ptr = &victim as *const _ as *const u8;
    let buffer_ptr = &mut buffer as *mut _ as *mut u8;
    // Copy from 'victim' to 'buffer' and forget 'victim'.
    // Semantically, 'buffer' now owns 'victim'.
    unsafe { ptr::copy_nonoverlapping(victim_ptr, buffer_ptr, size); }
    forget(victim);
    buffer
}
