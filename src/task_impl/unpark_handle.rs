use core::ptr;
use core::mem::{forget, size_of};
use core::marker::PhantomData;
use core::cell::Cell;
use super::Unpark;

// Stolen from https://gist.github.com/alexcrichton/29b618d75cde5b57d797
macro_rules! cascade {
    ($(
        if #[cfg($($meta:meta),*)] { $($it:item)* }
    ) else * else {
        $($it2:item)*
    }) => {
        __items! {
            () ;
            $( ( ($($meta),*) ($($it)*) ), )*
            ( () ($($it2)*) ),
        }
    }
}

macro_rules! __items {
    (($($not:meta,)*) ; ) => {};
    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {
        __apply! { cfg(all($($m,)* not(any($($not),*)))), $($it)* }
        __items! { ($($not,)* $($m,)*) ; $($rest)* }
    }
}

macro_rules! __apply {
    ($m:meta, $($it:item)*) => {
        $(#[$m] $it)*
    }
}

cascade! {
    if #[cfg(feature="MaxUnparkBytes1024")] {
        const _MAX_UNPARK_BYTES: usize = 1024;
    } else if #[cfg(feature="MaxUnparkBytes512")] {
        const _MAX_UNPARK_BYTES: usize = 512;
    } else if #[cfg(feature="MaxUnparkBytes256")] {
        const _MAX_UNPARK_BYTES: usize = 256;
    } else if #[cfg(feature="MaxUnparkBytes128")] {
        const _MAX_UNPARK_BYTES: usize = 128;
    } else {
        const _MAX_UNPARK_BYTES: usize = 64;
    }
}

/// Maximum size of `T` in `UnparkHandle<T>`, in bytes.
/// Configurable by the MaxUnparkBytes features.
pub const MAX_UNPARK_BYTES : usize = _MAX_UNPARK_BYTES;

/// A VTable that knows how to clone because the data has a maximum size.
#[derive(Copy)]
struct UnparkVtable {
    unpark: fn(*const ()),
    clone_to_byte_buffer: fn(*const ()) -> [u8; MAX_UNPARK_BYTES],
    drop_in_place: unsafe fn(*mut ()),
}

impl Clone for UnparkVtable {
    fn clone(&self) -> Self {
        UnparkVtable { ..*self }
    }
}

impl UnparkVtable {
    fn new<T: Unpark + Clone>() -> UnparkVtable {
        assert!(size_of::<T>() <= MAX_UNPARK_BYTES);
        UnparkVtable {
            unpark: Self::call_unpark::<T>,
            clone_to_byte_buffer: Self::clone_to_byte_buffer::<T>,
            drop_in_place: Self::drop_in_place::<T>,
        }
    }

    fn call_unpark<T: Unpark>(data: *const ()) {
        let downcasted = unsafe { &*(data as *const _ as *const T) };
        downcasted.unpark()
    }

    /// Returns array with bytes of the cloned data. Safe if data is shorter than MAX_UNPARK_BYTES.
    /// The caller owns the new data and is responsible for dropping it with `drop_in_place<T>`.
    fn clone_to_byte_buffer<T: Clone>(data: *const ()) -> [u8; MAX_UNPARK_BYTES] {
        let downcasted = unsafe { &*(data as *const _ as *const T) };
        obliviate(downcasted.clone())
    }

    /// Make sure the original value is forgotten to avoid double free.
    unsafe fn drop_in_place<T>(data: *mut ()) {
        ptr::drop_in_place(&mut *(data as *mut _ as *mut T));
    }
}

/// `UnparkHandle` is used as an argument to methods like `poll_future`.
///  Each `Task` handle generated by `task::park` will contain a fresh clone
///  of the `unpark` argument provided to `UnparkHandle::new`.
///  Depending on your use case, you may want to wrap your `unpark` value in
///  an `Arc` before passing it to the `UnparkHandle`.
///
/// # Deciding whether to use an `Arc`
/// If you use inner mutability in your `unpark`, then you should carefully
/// consider what happens when it is cloned and what is the behaviour you want.
/// Inner mutability aside, the only difference between using or not an `Arc` should be performance.
/// An `Arc` will cost an allocation upfront and updates an atomic ref count on park,
/// while no `Arc` has no upfront cost but will cost a clone on park.
/// The best strategy depends on how often your futures park and how costly it is to clone `unpark`.
#[allow(missing_debug_implementations)]
pub struct UnparkHandle {
    // A custom trait object that takes ownership of the data as a slice of bytes.
    // Can clone it's `data`, goes inside a `Task`.
    data: [u8; MAX_UNPARK_BYTES],
    vtable: UnparkVtable,
    not_sync : PhantomData<Cell<()>> // Cell is Send but not Sync, convenient.
}

impl UnparkHandle {
    /// Constructs a `UnparkHandle`.
    /// A `Task` handle returned by `park` will contain a clone of the `unpark`
    /// argument provided here. You may want to wrap `unpark` in an `Arc`.
    ///
    /// # Panic
    /// Panics if the size of 'T' is too large. If you get a panic wrap `unpark`
    /// in an `Arc` or use the MaxUnparkBytes features to increase the maximum size.
    pub fn new<T: Unpark + Clone + 'static>(unpark: T) -> UnparkHandle {
        if size_of::<T>() > MAX_UNPARK_BYTES {
            // Just panic since this is easy to catch and fix when testing.
            // Could be a compile time error when we get a const system in Rust.
            // Libraries that pass a user supplied T should do this check themselves if they want to avoid the panic.
            panic!("The size of T is {} bytes which is larger than MAX_UNPARK_BYTES={}. 
                    Wrap the unpark parameter in an Arc or use a sufficiently large MaxUnparkBytes feature.", size_of::<T>(), MAX_UNPARK_BYTES);
        }

        UnparkHandle {
            data: obliviate(unpark),
            vtable: UnparkVtable::new::<T>(),
            not_sync: PhantomData
        }
    }
}

impl Drop for UnparkHandle {
    fn drop(&mut self) {
        unsafe {
            (self.vtable.drop_in_place)(&mut self.data as *mut _ as *mut ());
        }
    }
}

impl Clone for UnparkHandle {
    fn clone(&self) -> Self {
        UnparkHandle {
            data: (self.vtable.clone_to_byte_buffer)(&self.data as *const _ as *const ()),
            ..*self
        }
    }
}

impl Unpark for UnparkHandle {
    fn unpark(&self) {
        (self.vtable.unpark)(&self.data as *const _ as *const ())
    }
}

/// Turns the victim into raw bytes and forgets it.
/// The caller now owns the value and is responsible for dropping it with 'drop_in_place<T>'.
fn obliviate<T>(victim : T) -> [u8; MAX_UNPARK_BYTES] {
    let size = size_of::<T>();
    assert!(size < MAX_UNPARK_BYTES);
    let mut buffer = [0; MAX_UNPARK_BYTES];
    // View victim and buffer as raw bytes.
    let victim_ptr = &victim as *const _ as *const u8;
    let buffer_ptr = &mut buffer as *mut _ as *mut u8;
    // Copy from 'victim' to 'buffer' and forget 'victim'.
    // Semantically, 'buffer' now owns 'victim'.
    unsafe { ptr::copy_nonoverlapping(victim_ptr, buffer_ptr, size); }
    forget(victim);
    buffer
}
